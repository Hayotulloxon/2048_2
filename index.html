<!doctype html> <html lang="en"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width,initial-scale=1" /> <title>Professional 2048 ‚Äî Telegram WebApp + Firebase Demo</title> <!-- Google Font (allowed public CDN) --> <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet"> <style> :root{ --bg:#071029; --card:#071427; --muted:#9fb0c8; --accent:#4f9cff; --accent-2:#7dd3fc; --glass: rgba(255,255,255,0.03); --tile-empty: rgba(255,255,255,0.04); --success:#8be28b; color-scheme: dark; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; } *{box-sizing:border-box} html,body{height:100%;margin:0;background:linear-gradient(180deg,#041028 0%,#051722 100%);color:#e7f0fb;-webkit-font-smoothing:antialiased} .container{max-width:1200px;margin:24px auto;padding:20px;display:grid;grid-template-columns:360px 1fr;gap:20px;align-items:start} header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;gap:16px} h1{margin:0;font-size:20px;display:flex;gap:10px;align-items:center} .tag{font-size:12px;color:var(--muted);background:rgba(255,255,255,0.02);padding:6px;border-radius:8px} .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 8px 36px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)} .left{display:flex;flex-direction:column;gap:12px} .profile{display:flex;align-items:center;gap:12px} .avatar{width:64px;height:64px;border-radius:12px;background:linear-gradient(90deg,#0e1724,#0b1a2a);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:22px} .meta{display:flex;flex-direction:column} .meta .name{font-weight:700} .meta .sub{font-size:13px;color:var(--muted)} .stats{display:flex;gap:10px;flex-wrap:wrap} .stat{background:var(--glass);padding:8px;border-radius:10px;min-width:110px;text-align:center} .board-wrap{display:flex;flex-direction:column;gap:10px;align-items:center} .board{width:340px;height:340px;background:linear-gradient(180deg,#071227,#061322);padding:14px;border-radius:12px;display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(4,1fr);gap:12px;border:1px solid rgba(255,255,255,0.03)} .cell{background:var(--tile-empty);border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px;color:#08111a;min-height:44px} .controls{display:flex;gap:8px;align-items:center} button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.035);color:var(--accent);padding:8px 10px;border-radius:10px;cursor:pointer} .btn-primary{background:linear-gradient(180deg,var(--accent),#2b7be6);color:white;border:none} .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted)} .small{font-size:13px;color:var(--muted)} .tasks{display:flex;flex-direction:column;gap:10px} .task{display:flex;flex-direction:column;gap:8px;padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent)} input[type="text"],input[type="number"],select,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.035);background:transparent;color:inherit} .admin{display:flex;flex-direction:column;gap:8px} .leaderboard{display:flex;flex-direction:column;gap:6px} .leader-row{display:flex;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)} footer{grid-column:1/-1;margin-top:6px;color:var(--muted);font-size:13px;display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap} .warning{background:linear-gradient(90deg, rgba(245,158,11,0.09), rgba(245,158,11,0.04));border-left:4px solid rgba(245,158,11,0.18);padding:10px;border-radius:8px;color:#ffdca8} .flex{display:flex;gap:8px;align-items:center} .right-col{display:flex;flex-direction:column;gap:12px} .muted-note{font-size:13px;color:var(--muted);padding-top:6px} .kbd{background:#051423;padding:3px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-weight:600} @media(max-width:980px){.container{grid-template-columns:1fr;padding:12px}.board{width:90vw;height:90vw;max-width:380px;max-height:380px}} </style> </head> <body> <div class="container" role="application" aria-label="2048 Telegram WebApp demo"> <header> <h1>üèÜ 2048 ‚Äî Professional Demo <span class="tag">Telegram WebApp ¬∑ Firebase RTDB</span></h1> <div class="small">Polished UI ‚Ä¢ Tasks ‚Ä¢ Admin ‚Ä¢ Leaderboard ‚Ä¢ Secure integration notes</div> </header>
<!-- LEFT / GAME COLUMN -->
<section class="left">
  <div class="card profile" aria-hidden="false">
    <div class="avatar" id="avatar">G</div>
    <div class="meta">
      <div class="name" id="username">Guest</div>
      <div class="sub" id="user-meta">Not signed</div>
    </div>
    <div style="margin-left:auto;text-align:right">
      <div class="small">UID</div>
      <div id="uid" style="font-size:12px;word-break:break-all">‚Äî</div>
    </div>
  </div>

  <div class="card">
    <div class="stats" role="status" aria-live="polite">
      <div class="stat">
        <div class="small">Score</div>
        <div id="score" style="font-size:20px">0</div>
      </div>
      <div class="stat">
        <div class="small">Moves</div>
        <div id="moves" style="font-size:20px">0</div>
      </div>
      <div class="stat">
        <div class="small">Best</div>
        <div id="best" style="font-size:20px">0</div>
      </div>
    </div>
    <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
      <button id="newGame" class="btn-primary">New Game</button>
      <button id="undo" class="btn-ghost">Undo</button>
      <div style="margin-left:auto" class="small">Games Played: <strong id="gamesPlayed">0</strong></div>
    </div>
  </div>

  <div class="card board-wrap" aria-label="game area">
    <div style="display:flex;justify-content:space-between;width:100%;align-items:center">
      <div class="small">Use <span class="kbd">‚Üë ‚Üì ‚Üê ‚Üí</span> or swipe on mobile.</div>
      <div class="small">Coins: <strong id="coins">0</strong></div>
    </div>
    <div class="board" id="board" role="grid" aria-label="2048 board"></div>
  </div>

  <div class="card warning">
    <div style="font-weight:700">Security & Operational Notes</div>
    <div class="muted-note">
      Client cannot safely verify Telegram channel membership or perform trusted writes (leaderboard). Use a server (Cloud Function or backend) to call Telegram Bot API and to write to sensitive DB paths.
    </div>
  </div>
</section>

<!-- RIGHT / TASKS, ADMIN, LEADERBOARD -->
<aside class="right-col">
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700">Tasks (Quests)</div>
      <div class="small">Server endpoint: <span id="server-endpoint-display">not configured</span></div>
    </div>
    <div class="tasks" id="tasksList" style="margin-top:12px">
      <div class="small">Loading tasks‚Ä¶</div>
    </div>
    <div style="margin-top:8px" class="muted-note">
      Tasks types: <strong>code</strong> (client-checked secret), <strong>subscribe</strong> (server verifies via Bot API), <strong>play</strong> (requires N games).
    </div>
  </div>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700">Leaderboard (Top 10)</div>
      <div class="small">Read-only from /leaderboard</div>
    </div>
    <div class="leaderboard" id="leaderboard" style="margin-top:10px">
      <div class="small">Loading leaderboard‚Ä¶</div>
    </div>
    <div class="small" style="margin-top:8px;color:#ffd9d9">
      Note: Client-side writes to /leaderboard should be disabled. Use server-side logic or Cloud Functions to update the leaderboard.
    </div>
  </div>

  <div class="card admin">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700">Admin Panel</div>
      <div style="display:flex;gap:6px;align-items:center">
        <label class="small">Demo Admin</label>
        <input type="checkbox" id="adminDemo" aria-label="demo admin toggle" />
      </div>
    </div>

    <div id="adminPanel" style="display:none;flex-direction:column;gap:8px">
      <div class="small">Detected admin: <span id="adminName">‚Äî</span></div>

      <div style="margin-top:8px">
        <label class="small">Task Type</label>
        <select id="taskType">
          <option value="code">code</option>
          <option value="subscribe">subscribe</option>
          <option value="play">play</option>
        </select>
        <label class="small">Title</label>
        <input id="taskTitle" type="text" placeholder="Short title" />
        <label class="small">Description</label>
        <textarea id="taskDesc" rows="2" placeholder="Describe the objective"></textarea>
        <label class="small">Reward (coins)</label>
        <input id="taskCoins" type="number" min="1" max="500" value="5" />
        <div id="typeFields" style="margin-top:6px"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="createTask" class="btn-primary">Create Task</button>
          <button id="reloadTasks" class="btn-ghost">Reload Tasks</button>
        </div>
        <div class="muted-note" style="margin-top:8px">
          Client push to /tasks is attempted here. In production, write tasks from a trusted server (service account) or secure custom claims.
        </div>
      </div>
    </div>
  </div>

  <footer style="grid-column:1/-1">
    <div class="small">Firebase: Realtime DB + Auth (anonymous). Configure <code>SERVER_ENDPOINT</code> in the source. Bot token must remain server-side.</div>
  </footer>
</aside>

</div> <!-- MAIN APP LOGIC (single-file) --> <script type="module"> /** * Professional single-file 2048 Telegram WebApp demo * - All app logic is contained here. * - Firebase modular ES imports are used. * * Important: Replace SERVER_ENDPOINT with your backend URL before enabling subscribe verification. * For production: Use custom tokens or server-side linking to map Telegram users to Firebase auth accounts. */ // =========================== // CONFIGURATION (REQUIRED) // =========================== const firebaseConfig = { apiKey: "AIzaSyBYrMBCCnb1XiTM8EHn9u-vw7ACHAdvlaQ", authDomain: "project-3020568111544941346.firebaseapp.com", databaseURL: "https://project-3020568111544941346-default-rtdb.firebaseio.com", projectId: "project-3020568111544941346", storageBucket: "project-3020568111544941346.firebasestorage.app", messagingSenderId: "863166821030", appId: "1:863166821030:web:c222bcb42da96f3de1ba67", measurementId: "G-ZCNRBT9680" }; // Server endpoint (must be implemented on server). // Server expected behavior: // POST { telegramId, channel } -> returns { ok: true } if user is a member of channel (server calls getChatMember). const SERVER_ENDPOINT = ""; // <-- set to "https://yourserver.example/verify-subscribe" // BOT TOKEN EXAMPLE (COMMENTED) ‚Äî for server ONLY // const BOT_TOKEN = "8464698459:AAEiswJ5qaOJ7MMq2KDMdw7yE0m1icRyQt8"; // WARNING: Never embed bot tokens in client HTML. Use env vars on the server. // =========================== // FIREBASE IMPORTS (ES MODULES) // =========================== import { initializeApp } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js"; import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-auth.js"; import { getDatabase, ref, onValue, set, push, update, get, query, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-database.js"; const app = initializeApp(firebaseConfig); const auth = getAuth(app); const db = getDatabase(app); // =========================== // DOM REFS // =========================== const avatarEl = document.getElementById('avatar'); const usernameEl = document.getElementById('username'); const userMetaEl = document.getElementById('user-meta'); const uidEl = document.getElementById('uid'); const coinsEl = document.getElementById('coins'); const serverEndpointDisplay = document.getElementById('server-endpoint-display'); serverEndpointDisplay.textContent = SERVER_ENDPOINT || "not configured"; // =========================== // TELEGRAM WEBAPP DETECTION // =========================== let tgUser = null; try { if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) { tgUser = Telegram.WebApp.initDataUnsafe.user; if (tgUser.username && tgUser.username.startsWith("@")) tgUser.username = tgUser.username.slice(1); } } catch (e) { // Not in Telegram WebApp or Telegram object not available. } if (tgUser) { usernameEl.textContent = (tgUser.first_name || '') + (tgUser.last_name ? ' ' + tgUser.last_name : '') + (tgUser.username ? ' ( @' + tgUser.username + ' )' : ''); avatarEl.textContent = (tgUser.first_name || 'G')[0].toUpperCase(); userMetaEl.textContent = `Telegram ID: ${tgUser.id}`; document.getElementById('adminName').textContent = tgUser.username ? '@'+tgUser.username : '(no username)'; } else { usernameEl.textContent = "Guest (Anonymous)"; avatarEl.textContent = "G"; userMetaEl.textContent = "No Telegram WebApp data detected"; document.getElementById('adminName').textContent = "(not Telegram)"; } // =========================== // AUTHENTICATION (ANONYMOUS) // =========================== signInAnonymously(auth).catch(err => { console.error("Anonymous sign-in error:", err); alert("Firebase anonymous sign-in failed. See console."); }); let currentUid = null; let userNodeRef = null; let localUserSnapshot = {}; onAuthStateChanged(auth, async (user) => { if (user) { currentUid = user.uid; uidEl.textContent = currentUid; userNodeRef = ref(db, `users/${currentUid}`); // Initialize user if absent try { const snap = await get(userNodeRef); if (!snap.exists()) { const initData = { createdAt: Date.now(), coins: 0, bestScore: 0, gamesPlayed: 0, telegram: tgUser ? { id: tgUser.id, username: tgUser.username, first_name: tgUser.first_name } : null }; await set(userNodeRef, initData); } else if (tgUser) { // ensure telegram metadata is present const cur = snap.val(); if (!cur.telegram) { await update(userNodeRef, { telegram: { id: tgUser.id, username: tgUser.username, first_name: tgUser.first_name } }); } } } catch (e) { console.warn("Could not bootstrap user node (likely due to DB rules).", e); } // Live-sync profile onValue(userNodeRef, (snap) => { localUserSnapshot = snap.val() || {}; // Update UI document.getElementById('best').textContent = localUserSnapshot.bestScore || 0; document.getElementById('gamesPlayed').textContent = localUserSnapshot.gamesPlayed || 0; scoreDisplayRefresh(); coinsEl.textContent = localUserSnapshot.coins || 0; }, (err) => { console.warn("Failed to listen to user node:", err); }); // Start listening to tasks and leaderboard startTasksListener(); startLeaderboardListener(); } else { currentUid = null; uidEl.textContent = "‚Äî"; } }); // =========================== // 2048 GAME IMPLEMENTATION (4x4) // =========================== const boardEl = document.getElementById('board'); const scoreEl = document.getElementById('score'); const movesEl = document.getElementById('moves'); const bestEl = document.getElementById('best'); const newGameBtn = document.getElementById('newGame'); const undoBtn = document.getElementById('undo'); const SIZE = 4; let game = { grid: [], score: 0, moves: 0, best: 0, history: [] }; function initEmptyGrid(){ return Array.from({length:SIZE}, ()=> Array.from({length:SIZE}, ()=>0)); } function spawnRandom(grid){ const empties = []; for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) empties.push([r,c]); if (!empties.length) return false; const [r,c] = empties[Math.floor(Math.random()*empties.length)]; grid[r][c] = Math.random() < 0.9 ? 2 : 4; return true; } function newGame(){ game.grid = initEmptyGrid(); game.score = 0; game.moves = 0; game.history = []; spawnRandom(game.grid); spawnRandom(game.grid); renderBoard(); } function cloneGrid(g){ return g.map(r=>r.slice()); } function renderBoard(){ boardEl.innerHTML = ''; for (let r=0;r<SIZE;r++){ for (let c=0;c<SIZE;c++){ const val = game.grid[r][c]; const cell = document.createElement('div'); cell.className = 'cell'; cell.setAttribute('role','gridcell'); if (val) { cell.textContent = val; cell.style.background = `linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02))`; cell.style.fontSize = val >= 1024 ? '16px' : '20px'; } else { cell.textContent = ''; } boardEl.appendChild(cell); } } scoreEl.textContent = game.score; movesEl.textContent = game.moves; bestEl.textContent = Math.max(game.best, localUserSnapshot.bestScore || 0); } function canMove(grid){ // empty cell? for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) return true; // adjacency for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++){ if (r+1<SIZE && grid[r][c] === grid[r+1][c]) return true; if (c+1<SIZE && grid[r][c] === grid[r][c+1]) return true; } return false; } function slideAndMerge(arr){ const original = arr.slice(); const compact = arr.filter(x=>x); for (let i=0;i<compact.length-1;i++){ if (compact[i] === compact[i+1]){ compact[i] *= 2; game.score += compact[i]; compact.splice(i+1,1); } } while (compact.length < SIZE) compact.push(0); let moved = compact.some((v,i)=>v !== original[i]); return {arr: compact, moved}; } function move(direction){ // direction: 'left','right','up','down' const prev = cloneGrid(game.grid); let moved = false; if (direction === 'left' || direction === 'right'){ for (let r=0;r<SIZE;r++){ let row = game.grid[r].slice(); if (direction === 'right') row.reverse(); const res = slideAndMerge(row); let newRow = res.arr; if (direction === 'right') newRow.reverse(); game.grid[r] = newRow; if (res.moved) moved = true; } } else { for (let c=0;c<SIZE;c++){ let col = []; for (let r=0;r<SIZE;r++) col.push(game.grid[r][c]); if (direction === 'down') col.reverse(); const res = slideAndMerge(col); let newCol = res.arr; if (direction === 'down') newCol.reverse(); for (let r=0;r<SIZE;r++) game.grid[r][c] = newCol[r]; if (res.moved) moved = true; } } if (moved){ game.history.push({grid:prev, scoreBefore: game.score}); spawnRandom(game.grid); game.moves++; renderBoard(); if (!canMove(game.grid)){ handleGameOver(); } } } function handleGameOver(){ // coins = max(1, min(50, floor(score / 128))). const coins = Math.max(1, Math.min(50, Math.floor(game.score / 128))); showGameOverDialog(game.score, coins); } function showGameOverDialog(score, coins){ // simple modal const overlay = document.createElement('div'); overlay.className = 'card'; overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.margin = 'auto'; overlay.style.maxWidth = '520px'; overlay.style.height = '180px'; overlay.style.left = '0'; overlay.style.right = '0'; overlay.style.top = '16vh'; overlay.style.zIndex = 60; overlay.style.display = 'flex'; overlay.style.flexDirection = 'column'; overlay.style.justifyContent = 'space-between'; overlay.innerHTML = ` <div> <div style="font-weight:700">Game Over</div> <div class="small" style="margin-top:6px">Score: ${score} ‚Ä¢ Coins to claim: ${coins}</div> </div> <div style="display:flex;gap:8px"> <button id="claimBtn" class="btn-primary">Claim & Save</button> <button id="dismissBtn" class="btn-ghost">Close</button> </div> `; document.body.appendChild(overlay); document.getElementById('dismissBtn').onclick = ()=> document.body.removeChild(overlay); document.getElementById('claimBtn').onclick = async () => { await saveGameResult(score, coins); document.body.removeChild(overlay); }; } async function saveGameResult(score, coins){ if (!currentUid) { alert("Not signed in ‚Äî cannot save result."); return; } const userRef = ref(db, `users/${currentUid}`); try { const snap = await get(userRef); const cur = snap.exists() ? snap.val() : {}; const newBest = Math.max(cur.bestScore || 0, score); const newGames = (cur.gamesPlayed || 0) + 1; const newCoins = (cur.coins || 0) + coins; // Update user profile await update(userRef, { bestScore: newBest, gamesPlayed: newGames, coins: newCoins }); // Attempt to write to /leaderboard (likely blocked); for production use server-side writes try { const lbRef = ref(db, `leaderboard/${currentUid}`); await set(lbRef, { uid: currentUid, username: (tgUser && tgUser.username) ? tgUser.username : "guest", score, timestamp: Date.now() }); } catch (e){ console.warn("Client write to /leaderboard likely blocked. Use server-side write instead.", e); } alert("Result saved. Thank you!"); } catch (e){ console.error("Failed to save game result:", e); alert("Could not save result (check DB rules). See console."); } } function scoreDisplayRefresh(){ document.getElementById('score').textContent = game.score; document.getElementById('best').textContent = localUserSnapshot.bestScore || 0; } // Controls: keyboard & touch window.addEventListener('keydown', (e) => { const map = { ArrowLeft:'left', ArrowRight:'right', ArrowUp:'up', ArrowDown:'down' }; if (map[e.key]) { e.preventDefault(); move(map[e.key]); } }); // Swipe let touchStart = null; boardEl.addEventListener('touchstart', (e)=> { const t = e.touches[0]; touchStart = {x: t.clientX, y: t.clientY}; }, {passive:true}); boardEl.addEventListener('touchend', (e)=> { if (!touchStart) return; const t = e.changedTouches[0]; const dx = t.clientX - touchStart.x, dy = t.clientY - touchStart.y; if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) move(dx>0?'right':'left'); else if (Math.abs(dy) > 30) move(dy>0?'down':'up'); touchStart = null; }, {passive:true}); newGameBtn.addEventListener('click', ()=> newGame()); undoBtn.addEventListener('click', ()=> { if (game.history.length){ const last = game.history.pop(); game.grid = last.grid; game.score = last.scoreBefore; game.moves = Math.max(0, game.moves-1); renderBoard(); } }); // initialize game newGame(); // =========================== // TASKS (Quests) ‚Äî /tasks (public read) // =========================== const tasksListEl = document.getElementById('tasksList'); let tasksCache = {}; function startTasksListener(){ const tasksRef = ref(db, 'tasks'); onValue(tasksRef, (snap) => { tasksCache = snap.val() || {}; renderTasks(tasksCache); }, (err) => { console.warn("Failed to read tasks:", err); tasksListEl.innerHTML = `<div class="small">Cannot load tasks (check rules). See console.</div>`; }); } function renderTasks(tasks){ tasksListEl.innerHTML = ''; const ids = Object.keys(tasks || {}); if (!ids.length) { tasksListEl.innerHTML = `<div class="small">No tasks published.</div>`; return; } ids.forEach(id => { const t = tasks[id]; const entry = document.createElement('div'); entry.className = 'task'; entry.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"> <div style="font-weight:700">${t.title || '(untitled)'}</div> <div class="small">Reward: ${t.coins || 0} coins</div> </div> <div class="small">${t.description || ''}</div> <div id="task-body-${id}" style="margin-top:8px"></div> <div class="small" id="task-status-${id}"></div>`; tasksListEl.appendChild(entry); renderTaskBody(id,t); updateTaskStatusUI(id); }); } function userHasCompleted(taskId){ return !!(localUserSnapshot && localUserSnapshot.completed && localUserSnapshot.completed[taskId]); } function updateTaskStatusUI(id){ const statusEl = document.getElementById('task-status-'+id); if (!statusEl) return; if (userHasCompleted(id)){ statusEl.textContent = `Completed at ${new Date(localUserSnapshot.completed[id].ts).toLocaleString()}`; } else { statusEl.textContent = `Not completed`; } } function renderTaskBody(id, task){ const container = document.getElementById('task-body-'+id); container.innerHTML = ''; if (userHasCompleted(id)){ updateTaskStatusUI(id); return; } if (task.type === 'code'){ const inp = document.createElement('input'); inp.type = 'text'; inp.placeholder = 'Enter secret code'; const btn = document.createElement('button'); btn.textContent = 'Submit'; btn.onclick = async ()=> { const val = inp.value.trim(); // Client-side comparison against secret field stored in DB (this assumes secret is intentionally public). if (val && val === task.secret) { await markTaskComplete(id, task); } else { alert('Incorrect code.'); } }; container.appendChild(inp); container.appendChild(btn); } else if (task.type === 'subscribe'){ const channel = task.channel || ''; const chDisplay = channel.startsWith('@') ? channel : '@' + channel; const link = document.createElement('a'); link.href = `https://t.me/${channel.replace(/^@/,'')}`; link.target = '_blank'; link.rel = 'noopener noreferrer'; link.textContent = `Open ${chDisplay}`; link.style.marginRight = '8px'; const verifyBtn = document.createElement('button'); verifyBtn.textContent = 'Verify'; verifyBtn.onclick = async ()=>{ if (!SERVER_ENDPOINT) { alert('SERVER_ENDPOINT not configured. Verification requires a server to call Telegram Bot API.'); return; } const telegramId = tgUser ? tgUser.id : null; if (!telegramId) { const idPrompt = prompt('Telegram ID not detected. Please enter your Telegram ID for verification:'); if (!idPrompt) return; } try { verifyBtn.disabled = true; verifyBtn.textContent = 'Verifying...'; const resp = await fetch(SERVER_ENDPOINT, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ telegramId: tgUser ? tgUser.id : null, channel: channel.replace(/^@/,'') }) }); const json = await resp.json(); if (json && json.ok) { await markTaskComplete(id, task); } else { alert('Verification failed. Server returned ok:false. Check server logs.'); console.warn('Server verification response:', json); } } catch (e) { console.error('Verification request failed:', e); alert('Verification request failed. See console.'); } finally { verifyBtn.disabled = false; verifyBtn.textContent = 'Verify'; } }; container.appendChild(link); container.appendChild(verifyBtn); } else if (task.type === 'play'){ const minGames = task.minGames || 1; const gp = localUserSnapshot.gamesPlayed || 0; const info = document.createElement('div'); info.className = 'small'; info.textContent = `Requirement: Play ${minGames} games (you played ${gp}).`; const claimBtn = document.createElement('button'); claimBtn.textContent = 'Claim'; claimBtn.onclick = async ()=>{ const gpNow = localUserSnapshot.gamesPlayed || 0; if (gpNow >= minGames) await markTaskComplete(id, task); else alert(`You need ${minGames} games. You have ${gpNow}.`); }; container.appendChild(info); container.appendChild(claimBtn); } else { container.textContent = 'Unsupported task type.'; } } async function markTaskComplete(taskId, task){ if (!currentUid) { alert('Not signed in.'); return; } const completedRef = ref(db, `users/${currentUid}/completed/${taskId}`); const userRef = ref(db, `users/${currentUid}`); const ts = Date.now(); try { // write completed marker await set(completedRef, { ts, title: task.title || '', type: task.type }); } catch (e){ console.warn('Failed to write completed marker from client (may be blocked by rules).', e); } // credit coins try { const snap = await get(userRef); const cur = snap.exists() ? snap.val() : {}; const newCoins = (cur.coins || 0) + (task.coins || 0); await update(userRef, { coins: newCoins }); alert(`Task completed! +${task.coins || 0} coins credited.`); } catch (e){ console.error('Failed to credit coins:', e); alert('Failed to credit coins. See console.'); } } // =========================== // ADMIN UI: Create tasks (client attempt) // =========================== const adminCheckbox = document.getElementById('adminDemo'); const adminPanelEl = document.getElementById('adminPanel'); const taskTypeEl = document.getElementById('taskType'); const typeFieldsEl = document.getElementById('typeFields'); const createTaskBtn = document.getElementById('createTask'); const reloadTasksBtn = document.getElementById('reloadTasks'); function isAdmin(){ const tgName = (tgUser && tgUser.username) ? tgUser.username.replace(/^@/,'') : ''; return adminCheckbox.checked || (tgName.toLowerCase() === 'h08_09'.toLowerCase()); } function refreshAdmin(){ adminPanelEl.style.display = isAdmin() ? 'flex' : 'none'; } adminCheckbox.addEventListener('change', refreshAdmin); refreshAdmin(); function renderTypeFields(){ const t = taskTypeEl.value; typeFieldsEl.innerHTML = ''; if (t === 'code') { typeFieldsEl.innerHTML = ` <label class="small">Secret (client-checkable)</label> <input id="field_secret" type="text" placeholder="e.g. SECRET42" /> <label class="small">Hint (optional)</label> <input id="field_hint" type="text" placeholder="Where the code is shown" /> `; } else if (t === 'subscribe') { typeFieldsEl.innerHTML = ` <label class="small">Channel (without @)</label> <input id="field_channel" type="text" placeholder="channel_name" /> <label class="small">Message</label> <input id="field_submsg" type="text" placeholder="Subscribe for news" /> `; } else if (t === 'play') { typeFieldsEl.innerHTML = ` <label class="small">Minimum games</label> <input id="field_minGames" type="number" min="1" value="3" /> `; } } taskTypeEl.addEventListener('change', renderTypeFields); renderTypeFields(); createTaskBtn.addEventListener('click', async ()=>{ if (!isAdmin()) { alert('Admin not detected. Toggle demo or sign in as @H08_09'); return; } const type = document.getElementById('taskType').value; const title = (document.getElementById('taskTitle').value || '').trim() || `Task ${Date.now()}`; const description = document.getElementById('taskDesc').value || ''; const coins = parseInt(document.getElementById('taskCoins').value) || 0; const payload = { type, title, description, coins, createdAt: Date.now() }; if (type === 'code') { payload.secret = document.getElementById('field_secret').value || ''; payload.hint = document.getElementById('field_hint').value || ''; } else if (type === 'subscribe') { let ch = (document.getElementById('field_channel').value || '').trim(); payload.channel = ch.replace(/^@/,''); payload.message = document.getElementById('field_submsg').value || ''; } else if (type === 'play') { payload.minGames = parseInt(document.getElementById('field_minGames').value) || 1; } try { const tasksRef = ref(db, 'tasks'); const pushRes = await push(tasksRef, payload); alert('Task created: ' + pushRes.key); } catch (e){ console.error('Task creation failed (client attempt).', e); alert('Could not create task from client. Use server-side writes or change DB rules. See console.'); } }); reloadTasksBtn.addEventListener('click', ()=> renderTasks(tasksCache)); // =========================== // LEADERBOARD (read top-10) // =========================== const leaderboardEl = document.getElementById('leaderboard'); function startLeaderboardListener(){ try { const q = query(ref(db, 'leaderboard'), orderByChild('score'), limitToLast(10)); onValue(q, (snap)=>{ const data = snap.val() || {}; renderLeaderboard(data); }, (err)=> { console.warn('Leaderboard read failed:', err); leaderboardEl.innerHTML = `<div class="small">Cannot read leaderboard (check rules). See console.</div>`; }); } catch (e) { console.error('Leaderboard listener setup error:', e); } } function renderLeaderboard(data){ leaderboardEl.innerHTML = ''; const arr = Object.values(data || {}); if (!arr.length) { leaderboardEl.innerHTML = `<div class="small">No leaderboard entries.</div>`; return; } arr.sort((a,b)=> (b.score||0) - (a.score||0)); arr.slice(0,10).forEach((r,idx)=>{ const div = document.createElement('div'); div.className = 'leader-row'; div.innerHTML = `<div>#${idx+1} ${(r.username ? ('@'+r.username) : (r.uid || 'anonymous'))}</div><div>${r.score||0}</div>`; leaderboardEl.appendChild(div); }); } // =========================== // TASKS & LEADERBOARD START (if auth already ready) // =========================== // onAuthStateChanged will call startTasksListener & startLeaderboardListener after sign-in completes. // =========================== // UTILITY: expose some debug helpers (dev only) // =========================== window._professional2048 = { firebaseConfig, SERVER_ENDPOINT, tgUser, getDb: ()=>db, getAuth: ()=>auth }; // =========================== // SERVER-SIDE PSEUDOCODE (FOR DEVELOPERS) // =========================== /** * Example Node/Express pseudocode for subscribe verification (server-side only) * * const express = require('express'); * const fetch = require('node-fetch'); * const app = express(); * app.use(express.json()); * const BOT_TOKEN = process.env.BOT_TOKEN; // store securely * * app.post('/verify-subscribe', async (req,res) => { * const { telegramId, channel } = req.body; * if (!telegramId || !channel) return res.status(400).json({ ok:false, error:'missing' }); * const url = `https://api.telegram.org/bot${BOT_TOKEN}/getChatMember?chat_id=@${encodeURIComponent(channel)}&user_id=${telegramId}`; * const r = await fetch(url); * const j = await r.json(); * if (j.ok && j.result && ['member','administrator','creator','restricted'].includes(j.result.status)) { * return res.json({ ok:true }); * } else { * return res.json({ ok:false, reason: j }); * } * }); * * // deploy this server or Cloud Function; keep BOT_TOKEN secret. */ // =========================== // FINAL NOTES // =========================== // - This single-file demo is designed for development and demonstration. // - For production: implement server-side verification, use Cloud Functions to update /leaderboard securely, // and if you need to associate Telegram accounts with Firebase users, mint custom tokens server-side. // // - Firebase DB rules (suggested) are below (as a commented JSON block at the end of the HTML). // </script> <!-- FIREBASE RULES SUGGESTION (copy into your Realtime Database rules): Note: Admin client writes may still fail unless using custom claims (auth.token.username) or server-side privileged writes. { "rules": { "users": { "$uid": { ".read": "auth.uid === $uid", ".write": "auth.uid === $uid || auth.token.username === 'H08_09'", "tasks": { ".read": true, ".write": "auth.uid === $uid" } } }, "tasks": { ".read": true, ".write": "auth.token.username === 'H08_09'" }, "leaderboard": { ".read": true, ".write": false } } } Comments: - The rules above allow users to read their own profile and write their profile. - Only a user with custom claim 'username' === 'H08_09' could write /tasks from client. - /leaderboard write is disabled for clients; perform leaderboard writes server-side (Cloud Function). --> </body> </html>
