<!doctype html> <html lang="uz"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width,initial-scale=1" /> <title>2048 — Telegram WebApp + Firebase (single-file)</title> <style> :root{ --bg:#071227; --card:#0b1630; --muted:#9fb3c8; --accent:#60a5fa; --glass:rgba(255,255,255,0.03); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; } *{box-sizing:border-box} html,body{height:100%;margin:0;background:linear-gradient(180deg,#041022,#071427);color:#eaf6ff} .container{max-width:1100px;margin:20px auto;padding:18px;display:grid;grid-template-columns:360px 1fr;gap:18px} header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between} h1{margin:0;font-size:20px} .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03)} .left{display:flex;flex-direction:column;gap:12px} .profile{display:flex;gap:12px;align-items:center} .avatar{width:56px;height:56px;border-radius:12px;background:linear-gradient(90deg,#0e1b2a,#122334);display:flex;align-items:center;justify-content:center;font-weight:700} .small{font-size:13px;color:var(--muted)} .stats{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px} .stat{background:var(--glass);padding:8px;border-radius:8px;min-width:100px;text-align:center} .board{width:320px;height:320px;background:#08182a;padding:12px;border-radius:12px;display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(4,1fr);gap:12px} .cell{background:rgba(255,255,255,0.02);border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;color:#041022} .controls{display:flex;gap:8px;align-items:center;margin-top:10px} input,select,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit} button{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--accent);cursor:pointer} .btn-primary{background:linear-gradient(180deg,var(--accent),#2b7be6);color:white;border:none} .tasks-list{display:flex;flex-direction:column;gap:10px;margin-top:12px} .task{padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent)} .leaderboard{display:flex;flex-direction:column;gap:6px;margin-top:10px} .leader-row{display:flex;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)} .warning{background:linear-gradient(90deg, rgba(245,158,11,0.08), rgba(245,158,11,0.03));border-left:4px solid rgba(245,158,11,0.12);padding:8px;border-radius:8px;color:#ffdca8;margin-top:12px} footer{grid-column:1/-1;margin-top:6px;color:var(--muted);font-size:13px;display:flex;justify-content:space-between;flex-wrap:wrap} @media (max-width:980px){.container{grid-template-columns:1fr;padding:12px}.board{width:90vw;height:90vw}} </style> </head> <body> <div class="container"> <header> <h1>2048 — Telegram WebApp + Firebase</h1> <div class="small">Single-file demo — Game • Tasks • Admin • Leaderboard</div> </header>
<!-- LEFT COLUMN: Profile + Game -->
<div class="left">
  <div class="card profile">
    <div class="avatar" id="avatar">U</div>
    <div>
      <div id="username" style="font-weight:700">Guest</div>
      <div id="user-meta" class="small">Not signed</div>
    </div>
    <div style="margin-left:auto;text-align:right">
      <div class="small">UID</div>
      <div id="uid" style="font-size:12px;word-break:break-all">—</div>
    </div>
  </div>

  <div class="card">
    <div class="stats" aria-live="polite">
      <div class="stat"><div class="small">Score</div><div id="score" style="font-size:18px">0</div></div>
      <div class="stat"><div class="small">Moves</div><div id="moves" style="font-size:18px">0</div></div>
      <div class="stat"><div class="small">Best</div><div id="best" style="font-size:18px">0</div></div>
    </div>

    <div class="controls">
      <button id="newGame" class="btn-primary">New Game</button>
      <button id="undo">Undo</button>
      <div style="margin-left:auto" class="small">Games: <span id="gamesPlayed">0</span></div>
    </div>
  </div>

  <div class="card">
    <div class="small">Board — use arrows or swipe</div>
    <div id="board" class="board" role="grid" aria-label="2048 board"></div>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
      <div class="small">Coins: <strong id="coins">0</strong></div>
      <div class="small" id="server-endpoint-display">Server: not configured</div>
    </div>
  </div>

  <div class="card warning">
    <strong>Security notice</strong>
    <div class="small" style="margin-top:6px">
      Client cannot securely perform Telegram channel membership checks (getChatMember) or trusted writes to leaderboard. These must be done on a trusted server (Cloud Function / backend) using the bot token or service account. See comments in the source for server examples.
    </div>
  </div>
</div>

<!-- RIGHT COLUMN: Tasks, Leaderboard, Admin -->
<div>
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700">Tasks (Quests)</div>
      <div class="small">Server endpoint: <span id="server-endpoint-label">not configured</span></div>
    </div>
    <div id="tasksList" class="tasks-list"><div class="small">Loading tasks…</div></div>
    <div class="small" style="margin-top:8px">Types: <strong>code</strong>, <strong>subscribe</strong>, <strong>play</strong></div>
  </div>

  <div class="card" style="margin-top:12px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700">Leaderboard (Top-10)</div>
      <div class="small">Read-only</div>
    </div>
    <div id="leaderboard" class="leaderboard"><div class="small">Loading leaderboard…</div></div>
    <div class="small" style="margin-top:8px;color:#ffd9d9">
      Note: Provided DB rules set <code>/leaderboard .write = false</code>. Writing must be performed server-side (Cloud Function or backend).
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700">Admin Panel</div>
      <div style="display:flex;gap:8px;align-items:center">
        <label class="small">Demo admin</label>
        <input type="checkbox" id="adminDemo">
      </div>
    </div>

    <div id="adminPanel" style="display:none;margin-top:10px">
      <div class="small">Detected admin: <span id="adminName">—</span></div>
      <label class="small" style="margin-top:8px">Type</label>
      <select id="taskType"><option value="code">code</option><option value="subscribe">subscribe</option><option value="play">play</option></select>
      <label class="small">Title</label>
      <input id="taskTitle" type="text" placeholder="Task title">
      <label class="small">Description</label>
      <textarea id="taskDesc" rows="2" placeholder="Task description"></textarea>
      <label class="small">Coins reward</label>
      <input id="taskCoins" type="number" min="1" value="5">
      <div id="typeFields" style="margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="createTask" class="btn-primary">Create task (push /tasks)</button>
        <button id="reloadTasks">Reload tasks</button>
      </div>
      <div class="small" style="margin-top:8px;color:#ffd9d9">
        Note: Pushing to <code>/tasks</code> from anonymous client may fail due to DB rules. Use server-side admin writes or grant custom claims to the admin account.
      </div>
    </div>
  </div>

  <footer style="margin-top:12px">
    <div class="small">Anonymous Firebase Auth + RTDB. Configure <code>SERVER_ENDPOINT</code> in code to enable subscribe verification.</div>
  </footer>
</div>

</div> <!-- Application logic (single-file). Uses Firebase modular SDK via CDN ES modules --> <script type="module"> /*********************************************************************** * Single-file 2048 + Tasks + Firebase + Telegram WebApp demo * - All logic, UI and comments are in this file. * * IMPORTANT: * - Replace SERVER_ENDPOINT with your verification endpoint on the server * to enable subscribe verification. See server pseudocode below. * - BOT_TOKEN example is included below as a COMMENT ONLY. Never embed * bot tokens in client code. Use server-only environment variables. ***********************************************************************/ // ========================= // Firebase config (exact) // ========================= const firebaseConfig = { apiKey: "AIzaSyBYrMBCCnb1XiTM8EHn9u-vw7ACHAdvlaQ", authDomain: "project-3020568111544941346.firebaseapp.com", databaseURL: "https://project-3020568111544941346-default-rtdb.firebaseio.com", projectId: "project-3020568111544941346", storageBucket: "project-3020568111544941346.firebasestorage.app", messagingSenderId: "863166821030", appId: "1:863166821030:web:c222bcb42da96f3de1ba67", measurementId: "G-ZCNRBT9680" }; // SERVER_ENDPOINT (set to your backend endpoint to perform Telegram getChatMember checks). // Server must accept POST JSON: { telegramId, channel } and return { ok: true } on success. // Leave empty for demo; Verify button will inform user if not set. const SERVER_ENDPOINT = ""; // <-- set your server URL here, e.g. "https://api.example.com/verify-subscribe" // BOT TOKEN (ONLY AS COMMENT - server use only) // const BOT_TOKEN = "8464698459:AAEiswJ5qaOJ7MMq2KDMdw7yE0m1icRyQt8"; // WARNING: Never embed bot tokens in client HTML/JS. Use server env vars. // ========================= // Import Firebase modular SDK (ES modules) // ========================= import { initializeApp } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js"; import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-auth.js"; import { getDatabase, ref, onValue, set, push, update, get, query, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-database.js"; const app = initializeApp(firebaseConfig); const auth = getAuth(app); const db = getDatabase(app); // ========================= // Detect Telegram.WebApp user info (if available) // ========================= let tgUser = null; try { if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) { tgUser = Telegram.WebApp.initDataUnsafe.user; if (tgUser.username && tgUser.username.startsWith('@')) tgUser.username = tgUser.username.slice(1); } } catch (e) { console.warn("Telegram WebApp not available:", e); } // DOM refs const avatarEl = document.getElementById('avatar'); const usernameEl = document.getElementById('username'); const userMetaEl = document.getElementById('user-meta'); const uidEl = document.getElementById('uid'); const scoreEl = document.getElementById('score'); const movesEl = document.getElementById('moves'); const bestEl = document.getElementById('best'); const boardEl = document.getElementById('board'); const coinsEl = document.getElementById('coins'); const gamesPlayedEl = document.getElementById('gamesPlayed'); const serverEndpointDisplay = document.getElementById('server-endpoint-display'); const serverEndpointLabel = document.getElementById('server-endpoint-label'); const tasksListEl = document.getElementById('tasksList'); const adminCheckbox = document.getElementById('adminDemo'); const adminPanel = document.getElementById('adminPanel'); const adminNameEl = document.getElementById('adminName'); const taskTypeEl = document.getElementById('taskType'); const typeFieldsEl = document.getElementById('typeFields'); const createTaskBtn = document.getElementById('createTask'); const reloadTasksBtn = document.getElementById('reloadTasks'); const leaderboardEl = document.getElementById('leaderboard'); serverEndpointDisplay.textContent = SERVER_ENDPOINT || "not configured"; serverEndpointLabel.textContent = SERVER_ENDPOINT || "not configured"; if (tgUser) { usernameEl.textContent = `${tgUser.first_name || ''}${tgUser.last_name ? ' ' + tgUser.last_name: ''}${tgUser.username ? (' (@' + tgUser.username + ')') : ''}`; avatarEl.textContent = (tgUser.first_name || 'U')[0].toUpperCase(); userMetaEl.textContent = `Telegram ID: ${tgUser.id || '—'}`; adminNameEl.textContent = tgUser.username ? '@' + tgUser.username : "(no username)"; } else { usernameEl.textContent = "Guest (Anonymous)"; avatarEl.textContent = "U"; userMetaEl.textContent = "No Telegram WebApp data detected."; adminNameEl.textContent = "(not Telegram)"; } // ========================= // Authentication: anonymous // ========================= signInAnonymously(auth).catch(err => { console.error("Anonymous sign-in failed:", err); alert("Firebase anonymous sign-in failed. See console."); }); let currentUid = null; let userRef = null; let localUser = {}; onAuthStateChanged(auth, async (user) => { if (user) { currentUid = user.uid; uidEl.textContent = currentUid; userRef = ref(db, `users/${currentUid}`); // try to create base profile if missing (may fail if rules block) try { const snap = await get(userRef); if (!snap.exists()) { const initial = { createdAt: Date.now(), coins: 0, bestScore: 0, gamesPlayed: 0, telegram: tgUser ? { id: tgUser.id, username: tgUser.username, first_name: tgUser.first_name } : null }; await set(userRef, initial); } else if (tgUser) { const cur = snap.val(); if (!cur.telegram) await update(userRef, { telegram: { id: tgUser.id, username: tgUser.username, first_name: tgUser.first_name } }); } } catch (e) { console.warn("Could not initialize /users/{uid} (DB rules may block write):", e); } // subscribe to user's profile updates onValue(userRef, (snap) => { localUser = snap.val() || {}; bestEl.textContent = localUser.bestScore || 0; coinsEl.textContent = localUser.coins || 0; gamesPlayedEl.textContent = localUser.gamesPlayed || 0; }, (err) => { console.warn("Failed to listen /users/{uid}:", err); }); // start reading tasks and leaderboard subscribeTasks(); subscribeLeaderboard(); } else { currentUid = null; uidEl.textContent = "—"; } }); // ========================= // 2048 Game logic (4x4) // ========================= const SIZE = 4; let game = { grid: [], score: 0, moves: 0, history: [] }; function makeEmptyGrid(){ return Array.from({length:SIZE}, ()=> Array.from({length:SIZE}, ()=>0)); } function cloneGrid(g){ return g.map(r=>r.slice()); } function spawnTile(grid){ const empties = []; for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) empties.push([r,c]); if (!empties.length) return false; const [r,c] = empties[Math.floor(Math.random()*empties.length)]; grid[r][c] = Math.random() < 0.9 ? 2 : 4; return true; } function initNewGame(){ game.grid = makeEmptyGrid(); game.score = 0; game.moves = 0; game.history = []; spawnTile(game.grid); spawnTile(game.grid); render(); } function render(){ boardEl.innerHTML = ''; for (let r=0;r<SIZE;r++){ for (let c=0;c<SIZE;c++){ const v = game.grid[r][c]; const el = document.createElement('div'); el.className = 'cell'; if (v) { el.textContent = v; el.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02))'; el.style.fontSize = v>=1024 ? '16px' : '20px'; } boardEl.appendChild(el); } } scoreEl.textContent = game.score; movesEl.textContent = game.moves; // best displayed from localUser via onValue } function canMove(grid){ for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) return true; for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++){ if (r+1<SIZE && grid[r][c]===grid[r+1][c]) return true; if (c+1<SIZE && grid[r][c]===grid[r][c+1]) return true; } return false; } function slideAndMerge(row){ const original = row.slice(); let arr = row.filter(x=>x); for (let i=0;i<arr.length-1;i++){ if (arr[i]===arr[i+1]){ arr[i]*=2; game.score += arr[i]; arr.splice(i+1,1); } } while (arr.length < SIZE) arr.push(0); const moved = arr.some((v,i)=>v!==original[i]); return {arr,moved}; } function move(dir){ const prev = cloneGrid(game.grid); let moved = false; if (dir==='left' || dir==='right'){ for (let r=0;r<SIZE;r++){ let row = game.grid[r].slice(); if (dir==='right') row.reverse(); const res = slideAndMerge(row); row = res.arr; if (dir==='right') row.reverse(); game.grid[r] = row; if (res.moved) moved = true; } } else { for (let c=0;c<SIZE;c++){ let col = []; for (let r=0;r<SIZE;r++) col.push(game.grid[r][c]); if (dir==='down') col.reverse(); const res = slideAndMerge(col); let newCol = res.arr; if (dir==='down') newCol.reverse(); for (let r=0;r<SIZE;r++) game.grid[r][c] = newCol[r]; if (res.moved) moved = true; } } if (moved){ game.history.push({grid:prev, scoreBefore: game.score}); spawnTile(game.grid); game.moves++; render(); if (!canMove(game.grid)) onGameOver(); } } function onGameOver(){ // coins formula: coins = max(1, min(50, floor(score / 128))). const coins = Math.max(1, Math.min(50, Math.floor(game.score / 128))); showGameOverModal(game.score, coins); } function showGameOverModal(score, coins){ const modal = document.createElement('div'); modal.style.position='fixed'; modal.style.inset='0'; modal.style.display='flex'; modal.style.alignItems='center'; modal.style.justifyContent='center'; modal.style.zIndex='9999'; const panel = document.createElement('div'); panel.className='card'; panel.style.maxWidth='480px'; panel.style.width='92%'; panel.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">Game Over</div><div class="small">Score: ${score}</div></div> <div class="small" style="margin-top:10px">Siz ${coins} tangaga ega bo'ldingiz. (formula: max(1,min(50,floor(score/128))))</div> <div style="display:flex;gap:8px;margin-top:12px"><button id="claimBtn" class="btn-primary">Claim & Save</button><button id="closeBtn">Close</button></div>`; modal.appendChild(panel); document.body.appendChild(modal); document.getElementById('closeBtn').onclick = ()=> document.body.removeChild(modal); document.getElementById('claimBtn').onclick = async ()=>{ await claimGameCoins(score, coins); document.body.removeChild(modal); }; } async function claimGameCoins(score, coins){ if (!currentUid){ alert("Not signed in — cannot save score."); return; } const uRef = ref(db, `users/${currentUid}`); try { const snap = await get(uRef); const cur = snap.exists() ? snap.val() : {}; const newBest = Math.max(cur.bestScore || 0, score); const newGames = (cur.gamesPlayed || 0) + 1; const newCoins = (cur.coins || 0) + coins; await update(uRef, { bestScore: newBest, gamesPlayed: newGames, coins: newCoins }); // Try to write to /leaderboard (likely blocked by rules). In production, use server-side write. try { await set(ref(db, `leaderboard/${currentUid}`), { uid: currentUid, username: (tgUser && tgUser.username) ? tgUser.username : null, score, ts: Date.now() }); } catch (e){ console.warn("Client /leaderboard write failed or blocked (expected). Use server-side writes.", e); } alert("Saved. Thank you for playing."); } catch (e){ console.error("Failed to update user record:", e); alert("Could not save to Firebase (check DB rules). See console for details."); } } // keyboard & swipe window.addEventListener('keydown', (e) => { const map = { ArrowLeft:'left', ArrowRight:'right', ArrowUp:'up', ArrowDown:'down' }; if (map[e.key]) { move(map[e.key]); e.preventDefault(); } }); let touchStart = null; boardEl.addEventListener('touchstart', (e)=> { touchStart = e.touches[0]; }, {passive:true}); boardEl.addEventListener('touchend', (e)=> { if (!touchStart) return; const t = e.changedTouches[0]; const dx = t.clientX - touchStart.clientX, dy = t.clientY - touchStart.clientY; if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) move(dx>0 ? 'right' : 'left'); else if (Math.abs(dy) > 30) move(dy>0 ? 'down' : 'up'); touchStart = null; }, {passive:true}); document.getElementById('newGame').addEventListener('click', ()=> initNewGame()); document.getElementById('undo').addEventListener('click', ()=> { if (game.history.length){ const last = game.history.pop(); game.grid = last.grid; game.score = last.scoreBefore; game.moves = Math.max(0, game.moves-1); render(); } }); initNewGame(); // ========================= // Tasks: read /tasks (public read) // ========================= let tasksCache = {}; function subscribeTasks(){ try { const tRef = ref(db, 'tasks'); onValue(tRef, (snap)=>{ tasksCache = snap.val() || {}; renderTasks(tasksCache); }, (err)=>{ console.warn("Failed to read /tasks:", err); tasksListEl.innerHTML = `<div class="small">Cannot load tasks (check DB rules). See console.</div>`; }); } catch (e){ console.error("subscribeTasks error:", e); } } function renderTasks(tasks){ tasksListEl.innerHTML = ''; const ids = Object.keys(tasks || {}); if (!ids.length){ tasksListEl.innerHTML = `<div class="small">No tasks available.</div>`; return; } ids.forEach(id=>{ const t = tasks[id]; const node = document.createElement('div'); node.className='task'; node.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">${t.title||'(no title)'}</div><div class="small">+${t.coins||0} coins</div></div> <div class="small">${t.description||''}</div> <div id="task-body-${id}" style="margin-top:8px"></div> <div class="small" id="task-status-${id}" style="margin-top:6px"></div>`; tasksListEl.appendChild(node); renderTaskBody(id, t); updateTaskStatus(id); }); } function userCompleted(taskId){ return !!(localUser && localUser.completed && localUser.completed[taskId]); } function updateTaskStatus(taskId){ const el = document.getElementById('task-status-'+taskId); if (!el) return; if (userCompleted(taskId)) el.textContent = `Completed: ${new Date(localUser.completed[taskId].ts).toLocaleString()}`; else el.textContent = `Not completed`; } function renderTaskBody(id, task){ const cont = document.getElementById('task-body-'+id); cont.innerHTML = ''; if (userCompleted(id)){ updateTaskStatus(id); return; } if (task.type === 'code'){ const inp = document.createElement('input'); inp.type='text'; inp.placeholder='Enter secret code'; const btn = document.createElement('button'); btn.textContent='Submit'; btn.onclick = async ()=>{ if (inp.value.trim() === task.secret){ await completeTask(id, task); } else alert("Incorrect code."); }; cont.appendChild(inp); cont.appendChild(btn); } else if (task.type === 'subscribe'){ const ch = task.channel || ''; const link = document.createElement('a'); link.href = `https://t.me/${ch.replace(/^@/,'')}`; link.target='_blank'; link.textContent = ch.startsWith('@') ? ch : ('@' + ch); link.style.marginRight='8px'; const verify = document.createElement('button'); verify.textContent='Verify'; verify.onclick = async ()=>{ if (!SERVER_ENDPOINT){ alert("SERVER_ENDPOINT not configured. Verification requires a server."); return; } const telegramId = tgUser ? tgUser.id : null; if (!telegramId){ alert("Telegram ID not detected. Open WebApp from Telegram or supply server-side linkage."); return; } try { verify.disabled = true; verify.textContent = 'Checking...'; const resp = await fetch(SERVER_ENDPOINT, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ telegramId, channel: ch.replace(/^@/,'') }) }); const j = await resp.json(); if (j && j.ok){ await completeTask(id, task); } else { alert("Server verification failed (server should return { ok:true } on success)."); console.warn("verify response:", j); } } catch (e){ console.error("Verify error:", e); alert("Verification request failed. See console."); } finally { verify.disabled=false; verify.textContent='Verify'; } }; cont.appendChild(link); cont.appendChild(verify); } else if (task.type === 'play'){ const minGames = task.minGames || 1; const info = document.createElement('div'); info.className='small'; info.textContent = `Play ${minGames} games (you: ${localUser.gamesPlayed||0})`; const claim = document.createElement('button'); claim.textContent='Claim'; claim.onclick = async ()=>{ const gp = localUser.gamesPlayed || 0; if (gp >= minGames) await completeTask(id, task); else alert(`You need ${minGames} games. You have ${gp}.`); }; cont.appendChild(info); cont.appendChild(claim); } else { cont.textContent = 'Unsupported task type'; } } async function completeTask(taskId, task){ if (!currentUid){ alert("Not signed in."); return; } const completedRef = ref(db, `users/${currentUid}/completed/${taskId}`); const uRef = ref(db, `users/${currentUid}`); const ts = Date.now(); try { await set(completedRef, { ts, title: task.title || '', type: task.type }); } catch (e){ console.warn("Could not record completed marker from client (DB rules may block).", e); } try { const snap = await get(uRef); const cur = snap.exists() ? snap.val() : {}; const newCoins = (cur.coins || 0) + (task.coins || 0); await update(uRef, { coins: newCoins }); alert(`Task completed: +${task.coins || 0} coins`); } catch (e){ console.error("Could not credit coins:", e); alert("Could not credit coins (DB rules may block)."); } } // ========================= // Admin UI: detect @H08_09 or demo checkbox // ========================= function isAdmin(){ const tgName = tgUser && tgUser.username ? tgUser.username.replace(/^@/,'') : ''; return adminCheckbox.checked || (tgName && tgName.toLowerCase() === 'h08_09'.toLowerCase()); } function refreshAdminUI(){ adminPanel.style.display = isAdmin() ? 'block' : 'none'; } adminCheckbox.addEventListener('change', refreshAdminUI); refreshAdminUI(); // dynamic fields for task type function renderTypeFields(){ const t = taskTypeEl.value; typeFieldsEl.innerHTML = ''; if (t === 'code'){ typeFieldsEl.innerHTML = `<label class="small">Secret (client-checked)</label><input id="field_secret" type="text" placeholder="SECRET123">`; } else if (t === 'subscribe'){ typeFieldsEl.innerHTML = `<label class="small">Channel (without @)</label><input id="field_channel" type="text" placeholder="channel_name">`; } else if (t === 'play'){ typeFieldsEl.innerHTML = `<label class="small">Min games</label><input id="field_minGames" type="number" min="1" value="3">`; } } taskTypeEl.addEventListener('change', renderTypeFields); renderTypeFields(); createTaskBtn.addEventListener('click', async ()=>{ if (!isAdmin()){ alert("Not admin. Toggle demo admin or open in Telegram as @H08_09."); return; } const type = taskTypeEl.value; const title = (document.getElementById('taskTitle').value || '').trim() || ('Task ' + Date.now()); const description = document.getElementById('taskDesc').value || ''; const coins = parseInt(document.getElementById('taskCoins').value) || 0; const payload = { type, title, description, coins, createdAt: Date.now() }; if (type === 'code') payload.secret = document.getElementById('field_secret').value || ''; if (type === 'subscribe') payload.channel = (document.getElementById('field_channel').value || '').replace(/^@/,''); if (type === 'play') payload.minGames = parseInt(document.getElementById('field_minGames').value) || 1; try { const tasksRef = ref(db, 'tasks'); const p = await push(tasksRef, payload); alert("Task created: " + p.key); } catch (e){ console.error("Failed to create task from client:", e); alert("Could not create task. Client writes to /tasks may be blocked by DB rules. Use server-side admin SDK or custom claims."); } }); reloadTasksBtn.addEventListener('click', ()=> renderTasks(tasksCache)); // ========================= // Leaderboard: read top-10 // ========================= function subscribeLeaderboard(){ try { const q = query(ref(db, 'leaderboard'), orderByChild('score'), limitToLast(10)); onValue(q, (snap)=>{ const data = snap.val() || {}; renderLeaderboard(data); }, (err)=> { console.warn("Leaderboard read failed:", err); leaderboardEl.innerHTML = `<div class="small">Could not read leaderboard (check rules).</div>`; }); } catch (e){ console.error("subscribeLeaderboard error:", e); } } function renderLeaderboard(data){ leaderboardEl.innerHTML = ''; const arr = Object.values(data || {}); if (!arr.length){ leaderboardEl.innerHTML = `<div class="small">No leaderboard entries yet.</div>`; return; } arr.sort((a,b)=> (b.score||0) - (a.score||0)); arr.slice(0,10).forEach((r, idx)=>{ const div = document.createElement('div'); div.className='leader-row'; div.innerHTML = `<div>#${idx+1} ${(r.username ? ('@'+r.username) : (r.uid || 'anon'))}</div><div>${r.score||0}</div>`; leaderboardEl.appendChild(div); }); } // If auth already present, start listeners if (auth.currentUser) { subscribeTasks(); subscribeLeaderboard(); } // Expose debug helpers (dev only) window._demo = { firebaseConfig, SERVER_ENDPOINT, tgUser, getDb: ()=>db, getAuth: ()=>auth }; /* ========================= SERVER PSEUDOCODE (comments only) - Implement this endpoint on your server to verify Telegram channel subscription. - Use server-side Bot token (process.env.BOT_TOKEN) to call getChatMember. - Example Node/Express pseudocode: const express = require('express'), fetch = require('node-fetch'); const app = express(); app.use(express.json()); const BOT_TOKEN = process.env.BOT_TOKEN; // keep secret app.post('/verify-subscribe', async (req,res) => { const { telegramId, channel } = req.body; if (!telegramId || !channel) return res.status(400).json({ ok:false }); const url = `https://api.telegram.org/bot${BOT_TOKEN}/getChatMember?chat_id=@${encodeURIComponent(channel)}&user_id=${telegramId}`; const r = await fetch(url); const j = await r.json(); // j.ok && j.result.status in ['member','creator','administrator','restricted'] => success if (j.ok && j.result && ['member','administrator','creator','restricted'].includes(j.result.status)) return res.json({ ok:true }); return res.json({ ok:false, reason:j }); }); - Important: verify requests, authenticate callers if needed; do not rely solely on client-provided telegramId. ========================= */ /* ========================= Reply_markup hint for bot (how bot should open WebApp) - Example (bot-side): reply_markup: { inline_keyboard: [ [{ text: "Open 2048", web_app: { url: "https://your.domain/index.html" } }] ] } - Or use KeyboardButton with web_app for reply_keyboard. ========================= */ /* NOTES on Firebase Rules: See bottom of file (comment block) with recommended rules JSON. Under those rules: - /users/$uid read/write is limited to that user (or admin by custom claim username == 'H08_09'). - /tasks is public readable; writing is allowed only for admin custom claim 'H08_09'. - /leaderboard is readable but not writable by clients (write: false). Therefore: - Creating tasks from client will likely fail unless your admin account has custom claims or rules changed. - Writing leaderboard entries should be done server-side (Cloud Function) whenever you want to record top scores. */ </script> <!-- Recommended Firebase Realtime Database Rules (deploy this JSON as your rules). NOTE: With these rules, /tasks writes require auth.token.username === 'H08_09' (custom claim). /leaderboard.write is false; perform leaderboard writes server-side (Cloud Function or admin SDK). --> <!-- { "rules": { "users": { "$uid": { ".read": "auth.uid === $uid", ".write": "auth.uid === $uid || auth.token.username === 'H08_09'", "tasks": { ".read": true, ".write": "auth.uid === $uid" } } }, "tasks": { ".read": true, ".write": "auth.token.username === 'H08_09'" }, "leaderboard": { ".read": true, ".write": false } } } --> </body> </html>
