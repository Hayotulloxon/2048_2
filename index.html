<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Telegram WebApp</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --color-bg: #faf8ef;
            --color-grid: #bbada0;
            --color-text: #776e65;
            --font-stack: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
            --tile-bg-2: #eee4da;
            --tile-text-2: #776e65;
            --tile-bg-4: #ede0c8;
            --tile-text-4: #776e65;
            --tile-bg-8: #f2b179;
            --tile-text-8: #f9f6f2;
            --tile-bg-16: #f59563;
            --tile-text-16: #f9f6f2;
            --tile-bg-32: #f67c5f;
            --tile-text-32: #f9f6f2;
            --tile-bg-64: #f65e3b;
            --tile-text-64: #f9f6f2;
            --tile-bg-128: #edcf72;
            --tile-text-128: #f9f6f2;
            --tile-bg-256: #edcc61;
            --tile-text-256: #f9f6f2;
            --tile-bg-512: #edc850;
            --tile-text-512: #f9f6f2;
            --tile-bg-1024: #edc53f;
            --tile-text-1024: #f9f6f2;
            --tile-bg-2048: #edc22e;
            --tile-text-2048: #f9f6f2;
        }

        body {
            font-family: var(--font-stack);
            background-color: var(--color-bg);
            color: var(--color-text);
            margin: 0;
            padding: 20px;
            text-align: center;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .scores {
            display: flex;
            gap: 10px;
        }

        .score-box {
            background-color: var(--color-grid);
            color: #fff;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
        }

        .game-container {
            position: relative;
            background-color: var(--color-grid);
            border-radius: 6px;
            padding: 10px;
            touch-action: none;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .grid-cell {
            width: 100px;
            height: 100px;
            background-color: rgba(238, 228, 218, 0.35);
            border-radius: 3px;
        }

        .tile-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
        }

        .tile {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 45px;
            font-weight: bold;
            transition: transform 0.1s ease-in-out;
        }
        
        @keyframes appear {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .tile.new {
            animation: appear 0.2s ease-out;
        }

        .tile.merged {
            z-index: 10;
        }

        .tile-2 { background-color: var(--tile-bg-2); color: var(--tile-text-2); }
        .tile-4 { background-color: var(--tile-bg-4); color: var(--tile-text-4); }
        .tile-8 { background-color: var(--tile-bg-8); color: var(--tile-text-8); }
        .tile-16 { background-color: var(--tile-bg-16); color: var(--tile-text-16); }
        .tile-32 { background-color: var(--tile-bg-32); color: var(--tile-text-32); }
        .tile-64 { background-color: var(--tile-bg-64); color: var(--tile-text-64); }
        .tile-128 { background-color: var(--tile-bg-128); color: var(--tile-text-128); }
        .tile-256 { background-color: var(--tile-bg-256); color: var(--tile-text-256); }
        .tile-512 { background-color: var(--tile-bg-512); color: var(--tile-text-512); }
        .tile-1024 { background-color: var(--tile-bg-1024); color: var(--tile-text-1024); }
        .tile-2048 { background-color: var(--tile-bg-2048); color: var(--tile-text-2048); }
        .tile-sup { background-color: #3c3a32; color: #f9f6f2; }
        
        .game-message {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background: rgba(255, 255, 255, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            font-size: 24px;
            font-weight: bold;
        }

        .new-game-btn, .claim-btn, .tab-btn {
            background-color: #8f7a66;
            color: #f9f6f2;
            border-radius: 3px;
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            font-size: 16px;
            margin-top: 15px;
        }

        .new-game-btn:hover, .claim-btn:hover, .tab-btn:hover {
            opacity: 0.8;
        }

        .tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .tab-btn {
            background-color: #928478;
        }

        .tab-btn.active {
            background-color: #776e65;
        }

        .tab-content {
            display: none;
            margin-top: 20px;
            text-align: left;
        }

        .tab-content.active {
            display: block;
        }

        .tasks-list, .leaderboard-list {
            list-style: none;
            padding: 0;
        }

        .task-item, .leaderboard-item {
            background-color: #eee4da;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-item.completed {
            opacity: 0.6;
            text-decoration: line-through;
        }

        .task-item.completed .claim-btn {
            display: none;
        }

        .task-item h4 {
            margin: 0 0 5px 0;
        }

        .task-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .leaderboard-item {
            font-weight: bold;
        }

        .leaderboard-item span:last-child {
            color: #edc22e;
        }

        .admin-panel {
            display: none;
            background-color: #e9e5df;
            padding: 20px;
            border-radius: 6px;
            margin-top: 20px;
        }

        .admin-panel.active {
            display: block;
        }
        
        .admin-panel label, .admin-panel input, .admin-panel select, .admin-panel textarea {
            display: block;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .admin-panel button {
            width: auto;
        }

        .warning-box {
            background-color: #ffcccc;
            border: 1px solid #ff0000;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            color: #b00000;
        }
        
        .loading {
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
        }
        
        @media (max-width: 600px) {
            .grid-cell, .tile {
                width: 70px;
                height: 70px;
            }
            .tile {
                font-size: 30px;
            }
            .header {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>2048 Game</h1>
        <div class="header">
            <div id="user-info"></div>
            <div class="scores">
                <div class="score-box">
                    Score<br><span id="score">0</span>
                </div>
                <div class="score-box">
                    Moves<br><span id="moves">0</span>
                </div>
                <div class="score-box">
                    Best<br><span id="best-score">0</span>
                </div>
                <div class="score-box">
                    üí∞Coins<br><span id="coins">0</span>
                </div>
            </div>
        </div>
        
        <div class="warning-box">
            <h4>‚ö†Ô∏è Important Security Note</h4>
            This demo's subscription verification and leaderboard writes are handled client-side for simplicity. For a production app, **these actions must be handled by a secure backend server**. Never embed a Telegram Bot token in client code.
        </div>

        <div class="game-container">
            <div class="grid">
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
            </div>
            <div class="tile-container" id="tile-container"></div>
            <div class="game-message" id="game-message" style="display: none;">
                <p>Game Over!</p>
                <p>Coins Earned: <span id="earned-coins">0</span></p>
                <button class="new-game-btn" onclick="game.newGame()">Try Again</button>
            </div>
        </div>

        <div class="tabs">
            <button class="tab-btn active" onclick="showTab('game')">üéÆ Game</button>
            <button class="tab-btn" onclick="showTab('tasks')">‚úÖ Tasks</button>
            <button class="tab-btn" onclick="showTab('leaderboard')">üèÜ Leaderboard</button>
            <label>
                <input type="checkbox" id="admin-checkbox" onchange="toggleAdminPanel(this.checked)"> Admin UI (for demo)
            </label>
        </div>
        
        <div id="game" class="tab-content active">
            <p>Use arrow keys or swipe to move the tiles. Combine tiles to get 2048!</p>
            <button class="new-game-btn" onclick="game.newGame()">New Game</button>
        </div>

        <div id="tasks" class="tab-content">
            <p>Complete tasks to earn more coins!</p>
            <div class="loading" id="tasks-loading">Loading tasks...</div>
            <ul class="tasks-list" id="tasks-list"></ul>
        </div>

        <div id="leaderboard" class="tab-content">
            <p>Top 10 players by best score.</p>
            <div class="loading" id="leaderboard-loading">Loading leaderboard...</div>
            <div id="leaderboard-placeholder" style="display: none; text-align: center; margin-top: 20px;">
                <p>The leaderboard is currently empty.</p>
                <p><strong>Note:</strong> Leaderboard scores are typically updated by a backend server after each game to prevent client-side cheating. The client-side code here is only for displaying the list.</p>
            </div>
            <ul class="leaderboard-list" id="leaderboard-list"></ul>
        </div>
        
        <div id="admin-panel" class="admin-panel">
            <h3>Admin Panel</h3>
            <p>Add a new task:</p>
            <form id="add-task-form">
                <label for="task-type">Task Type:</label>
                <select id="task-type" name="type" required onchange="showTaskFields(this.value)">
                    <option value="code">Enter Code</option>
                    <option value="subscribe">Subscribe to Channel</option>
                    <option value="play">Play Games</option>
                </select>
                <label for="task-title">Title:</label>
                <input type="text" id="task-title" name="title" required>
                <label for="task-coins">Reward Coins:</label>
                <input type="number" id="task-coins" name="coins" required>

                <div id="task-fields-code">
                    <label for="task-secret">Secret Code:</label>
                    <input type="text" id="task-secret" name="secret">
                </div>
                <div id="task-fields-subscribe" style="display: none;">
                    <label for="task-channel">Channel Username (e.g., @mychannel):</label>
                    <input type="text" id="task-channel" name="channel">
                </div>
                <div id="task-fields-play" style="display: none;">
                    <label for="task-min-games">Min. Games Played:</label>
                    <input type="number" id="task-min-games" name="minGames">
                </div>
                <button type="submit">Add Task</button>
            </form>
            <p>
                <em>Note: Writing to the `/tasks` path requires admin privileges. With the suggested Firebase rules, this will only work for the user with the username 'H08_09'. Anonymous users will get a permission denied error. For a production system, this write should be done from a secure backend server using a service account or custom token.</em>
            </p>
        </div>
    </div>

    <script type="module">
        // Firebase CDN Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getDatabase, ref, onValue, set, get, push, update, child } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        
        // =================================================================
        // CONFIGURATIONS
        // =================================================================
        
        // Firebase Config (must be exactly as specified)
        const firebaseConfig = {
            apiKey: "AIzaSyBYrMBCCnb1XiTM8EHn9u-vw7ACHAdvlaQ",
            authDomain: "project-3020568111544941346.firebaseapp.com",
            databaseURL: "https://project-3020568111544941346-default-rtdb.firebaseio.com",
            projectId: "project-3020568111544941346",
            storageBucket: "project-3020568111544941346.firebasestorage.app",
            messagingSenderId: "863166821030",
            appId: "1:863166821030:web:c222bcb42da96f3de1ba67",
            measurementId: "G-ZCNRBT9680"
        };
        
        // Server endpoint for subscription verification.
        // Replace with your actual backend URL.
        const SERVER_ENDPOINT = "";
        
        // Telegram Bot Token (for server-side use only, NEVER in client-side code)
        // const BOT_TOKEN = "8464698459:AAEiswJ5qaOJ7MMq2KDMdw7yE0m1icRyQt8"; 
        
        /* * Example server-side pseudocode for subscription verification:
        *
        * async function verifySubscription(telegramId, channelUsername) {
        * const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getChatMember?chat_id=${channelUsername}&user_id=${telegramId}`);
        * const data = await response.json();
        * const status = data.result.status;
        * if (status === 'member' || status === 'creator' || status === 'administrator') {
        * return { ok: true };
        * } else {
        * return { ok: false, error: 'User not subscribed' };
        * }
        * }
        *
        */

        // Admin username for a simple client-side check
        const ADMIN_USERNAME = "H08_09";

        // =================================================================
        // APP INITIALIZATION
        // =================================================================
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);
        
        let userProfileRef;
        let telegramUser = null;
        let isTelegramWebApp = false;
        let currentUserId = null;

        // Check for Telegram WebApp context
        try {
            if (window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe) {
                isTelegramWebApp = true;
                telegramUser = window.Telegram.WebApp.initDataUnsafe.user;
                if (telegramUser && telegramUser.id) {
                    currentUserId = `tg_${telegramUser.id}`;
                }
            }
        } catch (e) {
            console.warn("Not running in Telegram WebApp context.");
        }
        
        // Listen for Firebase Auth state changes
        onAuthStateChanged(auth, (user) => {
            if (user) {
                // If we're in a Telegram WebApp, use a custom UID to link
                // the Firebase Anonymous user to the Telegram user.
                const uid = currentUserId || user.uid;
                userProfileRef = ref(db, `users/${uid}`);
                console.log(`Signed in with UID: ${uid}`);
                
                // If it's the first time signing in, set the basic user profile
                get(userProfileRef).then((snapshot) => {
                    if (!snapshot.exists()) {
                        set(userProfileRef, {
                            bestScore: 0,
                            gamesPlayed: 0,
                            coins: 0,
                            firstName: telegramUser?.first_name || '',
                            username: telegramUser?.username || '',
                            lastUpdated: Date.now()
                        });
                    }
                });

                // Live-sync user data
                onValue(userProfileRef, (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        document.getElementById('best-score').textContent = data.bestScore || 0;
                        document.getElementById('coins').textContent = data.coins || 0;
                        updateUserInfo(data);
                    }
                });

                // Set up tasks and leaderboard listeners
                setupTasksListener();
                setupLeaderboardListener();
                checkAdminStatus();
            } else {
                // Sign in anonymously if no user is found
                signInAnonymously(auth).catch((error) => {
                    console.error("Anonymous sign-in failed:", error);
                });
            }
        });

        function updateUserInfo(data) {
            const userInfoEl = document.getElementById('user-info');
            userInfoEl.innerHTML = '';
            let userName = data.firstName || 'Anonymous';
            if (data.username) {
                userName = `@${data.username}`;
            }
            userInfoEl.innerHTML = `<strong>Player:</strong> ${userName}`;
        }
        
        function checkAdminStatus() {
            const user = auth.currentUser;
            const isAdmin = (telegramUser && telegramUser.username === ADMIN_USERNAME) || document.getElementById('admin-checkbox').checked;
            if (isAdmin) {
                document.getElementById('admin-panel').classList.add('active');
            } else {
                document.getElementById('admin-panel').classList.remove('active');
            }
        }
        
        function toggleAdminPanel(checked) {
             checkAdminStatus(); // Re-check on checkbox change
        }

        function showTaskFields(type) {
            document.getElementById('task-fields-code').style.display = 'none';
            document.getElementById('task-fields-subscribe').style.display = 'none';
            document.getElementById('task-fields-play').style.display = 'none';
            document.getElementById(`task-fields-${type}`).style.display = 'block';
        }

        // =================================================================
        // TASK SYSTEM
        // =================================================================
        
        let tasks = {};

        function setupTasksListener() {
            const tasksRef = ref(db, 'tasks');
            const completedRef = ref(db, `users/${auth.currentUser.uid}/completed`);
            
            onValue(tasksRef, (snapshot) => {
                tasks = snapshot.val() || {};
                const tasksList = document.getElementById('tasks-list');
                tasksList.innerHTML = '';
                document.getElementById('tasks-loading').style.display = 'none';
                
                if (Object.keys(tasks).length === 0) {
                    tasksList.innerHTML = '<p style="text-align: center;">No tasks available at the moment. Check back later!</p>';
                    return;
                }

                onValue(completedRef, (completedSnapshot) => {
                    const completedTasks = completedSnapshot.val() || {};
                    for (const taskId in tasks) {
                        const task = tasks[taskId];
                        const li = document.createElement('li');
                        li.className = 'task-item';
                        if (completedTasks[taskId]) {
                            li.classList.add('completed');
                        }
                        
                        let taskActionsHtml = '';
                        if (!completedTasks[taskId]) {
                            if (task.type === 'code') {
                                taskActionsHtml = `
                                    <input type="text" class="code-input" placeholder="Enter code">
                                    <button class="claim-btn" onclick="checkCode('${taskId}')">Claim</button>
                                `;
                            } else if (task.type === 'subscribe') {
                                taskActionsHtml = `
                                    <a href="https://t.me/${task.channel.replace('@', '')}" target="_blank" class="claim-btn" style="text-decoration: none;">Join Channel</a>
                                    <button class="claim-btn" onclick="verifySubscription('${taskId}')">Verify</button>
                                `;
                            } else if (task.type === 'play') {
                                taskActionsHtml = `
                                    <p>Games Played: <span id="games-played-count">...</span> / ${task.minGames}</p>
                                    <button class="claim-btn" onclick="claimPlayTask('${taskId}')">Claim</button>
                                `;
                            }
                        }

                        li.innerHTML = `
                            <div>
                                <h4>${task.title}</h4>
                                <p>Reward: ${task.coins} coins</p>
                            </div>
                            <div class="task-actions">
                                ${taskActionsHtml}
                            </div>
                        `;
                        tasksList.appendChild(li);
                    }
                    updatePlayTaskUI();
                });
            }, {
                onlyOnce: false // Listen for real-time updates
            });
        }
        
        window.checkCode = function(taskId) {
            const task = tasks[taskId];
            const input = document.querySelector(`#tasks-list li[data-task-id="${taskId}"] .code-input`);
            if (input.value === task.secret) {
                completeTask(taskId, task.coins);
                alert('Code is correct! Coins credited.');
            } else {
                alert('Invalid code.');
            }
        }
        
        window.verifySubscription = async function(taskId) {
            const task = tasks[taskId];
            const telegramId = telegramUser?.id;

            if (!SERVER_ENDPOINT) {
                 alert('Server endpoint is not configured. Cannot verify subscription.');
                 return;
            }
            if (!telegramId) {
                 alert('Telegram ID not found. This verification requires running within the Telegram WebApp.');
                 return;
            }

            try {
                const response = await fetch(SERVER_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ telegramId: telegramId, channel: task.channel })
                });
                const result = await response.json();
                if (result.ok) {
                    completeTask(taskId, task.coins);
                    alert('Subscription verified successfully!');
                } else {
                    alert('Verification failed. Please ensure you have joined the channel.');
                }
            } catch (error) {
                console.error("Subscription verification failed:", error);
                alert('Verification failed. Server is unreachable or responded with an error.');
            }
        }

        window.claimPlayTask = function(taskId) {
            const task = tasks[taskId];
            get(userProfileRef).then((snapshot) => {
                const gamesPlayed = snapshot.val()?.gamesPlayed || 0;
                if (gamesPlayed >= task.minGames) {
                    completeTask(taskId, task.coins);
                    alert('Task completed! Coins credited.');
                } else {
                    alert(`You need to play ${task.minGames} games to claim this reward. You've played ${gamesPlayed}.`);
                }
            });
        }

        function updatePlayTaskUI() {
            const gamesPlayedRef = child(userProfileRef, 'gamesPlayed');
            onValue(gamesPlayedRef, (snapshot) => {
                const gamesPlayed = snapshot.val() || 0;
                const playTasks = document.querySelectorAll('.task-item[data-task-type="play"]');
                playTasks.forEach(item => {
                    const countSpan = item.querySelector('#games-played-count');
                    if (countSpan) {
                        countSpan.textContent = gamesPlayed;
                    }
                });
            });
        }
        
        function completeTask(taskId, coinsReward) {
            const updates = {};
            updates[`/users/${auth.currentUser.uid}/completed/${taskId}`] = Date.now();
            updates[`/users/${auth.currentUser.uid}/coins`] = (auth.currentUser.uid, {
                coins: increment(coinsReward)
            }); // This is client-side, needs a transaction for accuracy
            
            // Simple update for demo
            get(userProfileRef).then(snapshot => {
                const currentCoins = snapshot.val()?.coins || 0;
                set(child(userProfileRef, `completed/${taskId}`), Date.now());
                set(child(userProfileRef, 'coins'), currentCoins + coinsReward);
            });
        }
        
        // Add Task Form Handler (Admin UI)
        document.getElementById('add-task-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const form = e.target;
            const type = form.elements['task-type'].value;
            const title = form.elements['task-title'].value;
            const coins = parseInt(form.elements['task-coins'].value);
            
            let taskData = { type, title, coins };
            if (type === 'code') {
                taskData.secret = form.elements['task-secret'].value;
            } else if (type === 'subscribe') {
                taskData.channel = form.elements['task-channel'].value;
            } else if (type === 'play') {
                taskData.minGames = parseInt(form.elements['task-min-games'].value);
            }
            
            try {
                // This write requires admin privileges. With suggested rules, it will work for `@H08_09`
                const tasksRef = ref(db, 'tasks');
                await push(tasksRef, taskData);
                alert('Task added successfully!');
                form.reset();
            } catch (error) {
                console.error("Error adding task:", error);
                alert("Failed to add task. Check Firebase rules and ensure you have admin permissions.");
            }
        });

        // =================================================================
        // LEADERBOARD
        // =================================================================

        function setupLeaderboardListener() {
            const leaderboardRef = ref(db, 'leaderboard');
            onValue(leaderboardRef, (snapshot) => {
                const leaderboard = snapshot.val() || {};
                const leaderboardList = document.getElementById('leaderboard-list');
                leaderboardList.innerHTML = '';
                document.getElementById('leaderboard-loading').style.display = 'none';

                if (Object.keys(leaderboard).length === 0) {
                    document.getElementById('leaderboard-placeholder').style.display = 'block';
                    return;
                } else {
                    document.getElementById('leaderboard-placeholder').style.display = 'none';
                }

                // Convert object to array, sort by score, take top 10
                const sortedLeaders = Object.values(leaderboard).sort((a, b) => b.bestScore - a.bestScore).slice(0, 10);
                
                sortedLeaders.forEach((player, index) => {
                    const li = document.createElement('li');
                    li.className = 'leaderboard-item';
                    li.innerHTML = `<span>${index + 1}. ${player.firstName || player.username || 'Anonymous'}</span><span>${player.bestScore}</span>`;
                    leaderboardList.appendChild(li);
                });
            });
        }
        
        // =================================================================
        // 2048 GAME LOGIC
        // =================================================================

        const game = {
            gridSize: 4,
            grid: [],
            score: 0,
            moves: 0,
            isGameOver: false,
            tileContainer: document.getElementById('tile-container'),
            scoreEl: document.getElementById('score'),
            movesEl: document.getElementById('moves'),
            
            init: function() {
                this.newGame();
                this.setupInput();
            },
            
            newGame: function() {
                this.grid = this.emptyGrid();
                this.score = 0;
                this.moves = 0;
                this.isGameOver = false;
                this.updateScoreUI();
                this.tileContainer.innerHTML = '';
                document.getElementById('game-message').style.display = 'none';
                this.addRandomTile();
                this.addRandomTile();
                this.drawTiles();
            },
            
            emptyGrid: function() {
                return Array(this.gridSize).fill(null).map(() => Array(this.gridSize).fill(0));
            },
            
            addRandomTile: function() {
                const emptyCells = [];
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        if (this.grid[r][c] === 0) {
                            emptyCells.push({ r, c });
                        }
                    }
                }
                if (emptyCells.length > 0) {
                    const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const value = Math.random() < 0.9 ? 2 : 4;
                    this.grid[cell.r][cell.c] = value;
                    return true;
                }
                return false;
            },
            
            drawTiles: function() {
                this.tileContainer.innerHTML = '';
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        const value = this.grid[r][c];
                        if (value !== 0) {
                            const tile = document.createElement('div');
                            tile.className = `tile tile-${value > 2048 ? 'sup' : value}`;
                            tile.textContent = value;
                            tile.style.transform = `translate(${c * 110}px, ${r * 110}px)`; // 100px tile + 10px gap
                            this.tileContainer.appendChild(tile);
                        }
                    }
                }
            },
            
            move: function(direction) {
                if (this.isGameOver) return;
                
                let moved = false;
                const originalGrid = JSON.stringify(this.grid);
                
                // Helper function to get or set a row/column
                const getLine = (index) => {
                    if (direction === 'up' || direction === 'down') {
                        return this.grid.map(row => row[index]);
                    } else {
                        return this.grid[index];
                    }
                }
                const setLine = (index, line) => {
                    if (direction === 'up' || direction === 'down') {
                        for (let r = 0; r < this.gridSize; r++) {
                            this.grid[r][index] = line[r];
                        }
                    } else {
                        this.grid[index] = line;
                    }
                }
                
                for (let i = 0; i < this.gridSize; i++) {
                    let line = getLine(i);
                    if (direction === 'right' || direction === 'down') {
                        line.reverse();
                    }
                    
                    let newArr = line.filter(val => val !== 0);
                    let mergedArr = [];
                    for(let j=0; j<newArr.length; j++) {
                        if(newArr[j] === newArr[j+1]) {
                            const mergedValue = newArr[j] * 2;
                            mergedArr.push(mergedValue);
                            this.score += mergedValue;
                            j++;
                        } else {
                            mergedArr.push(newArr[j]);
                        }
                    }
                    
                    while (mergedArr.length < this.gridSize) {
                        mergedArr.push(0);
                    }
                    
                    if (direction === 'right' || direction === 'down') {
                        mergedArr.reverse();
                    }
                    
                    setLine(i, mergedArr);
                }
                
                if (JSON.stringify(this.grid) !== originalGrid) {
                    this.moves++;
                    this.addRandomTile();
                    this.drawTiles();
                    this.checkGameOver();
                }
                this.updateScoreUI();
            },
            
            checkGameOver: function() {
                if (!this.hasEmptyCells() && !this.hasPossibleMoves()) {
                    this.isGameOver = true;
                    this.endGame();
                }
            },
            
            hasEmptyCells: function() {
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        if (this.grid[r][c] === 0) return true;
                    }
                }
                return false;
            },
            
            hasPossibleMoves: function() {
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        const val = this.grid[r][c];
                        if (r < this.gridSize - 1 && val === this.grid[r+1][c]) return true;
                        if (c < this.gridSize - 1 && val === this.grid[r][c+1]) return true;
                    }
                }
                return false;
            },
            
            endGame: function() {
                const coinsEarned = Math.max(1, Math.min(50, Math.floor(this.score / 128)));
                document.getElementById('earned-coins').textContent = coinsEarned;
                document.getElementById('game-message').style.display = 'flex';
                this.updateFirebaseProfile(coinsEarned);
            },
            
            updateScoreUI: function() {
                this.scoreEl.textContent = this.score;
                this.movesEl.textContent = this.moves;
            },

            updateFirebaseProfile: function(coinsEarned) {
                const userRef = userProfileRef;
                if (!userRef) return;
                
                get(userRef).then((snapshot) => {
                    const profile = snapshot.val() || {};
                    const updates = {
                        bestScore: Math.max(profile.bestScore || 0, this.score),
                        gamesPlayed: (profile.gamesPlayed || 0) + 1,
                        coins: (profile.coins || 0) + coinsEarned,
                        lastUpdated: Date.now()
                    };
                    update(userRef, updates);
                });
            },
            
            setupInput: function() {
                const gameContainer = document.getElementById('game-container');
                let startX, startY;
                
                document.addEventListener('keydown', (e) => {
                    if (document.activeElement.tagName === 'INPUT') return;
                    e.preventDefault();
                    if (e.key === 'ArrowUp') this.move('up');
                    else if (e.key === 'ArrowDown') this.move('down');
                    else if (e.key === 'ArrowLeft') this.move('left');
                    else if (e.key === 'ArrowRight') this.move('right');
                });
                
                gameContainer.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                });
                
                gameContainer.addEventListener('touchend', (e) => {
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const diffX = endX - startX;
                    const diffY = endY - startY;
                    
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        if (Math.abs(diffX) > 30) {
                            this.move(diffX > 0 ? 'right' : 'left');
                        }
                    } else {
                        if (Math.abs(diffY) > 30) {
                            this.move(diffY > 0 ? 'down' : 'up');
                        }
                    }
                });
            }
        };

        // Initialize the game after the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            game.init();
        });
        
        // Tab switching logic
        window.showTab = function(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab-btn[onclick="showTab('${tabId}')"]`).classList.add('active');
        }

    </script>

    </body>
</html>
